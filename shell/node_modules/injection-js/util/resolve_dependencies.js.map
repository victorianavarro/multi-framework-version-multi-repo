{"version":3,"file":"resolve_dependencies.js","sourceRoot":"","sources":["../../lib/util/resolve_dependencies.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,wBAAwB,CAAC;AAK5D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2CG;AACH,MAAM,UAAU,mBAAmB,CAAC,GAAG,MAAqB;IAC1D,MAAM,IAAI,GAAG,IAAI,GAAG,EAAe,CAAC;IAEpC,SAAS,QAAQ,CAAC,KAAkB;QAClC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAAE,OAAO;QAE5B,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAEhB,mFAAmF;QACnF,kCAAkC;QAClC,kBAAkB,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC;aAChC,MAAM,CAAC,CAAC,CAAC,EAAE,CAA6B,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,iBAAiB,CAAC,EAAE,EAAiC,CAAC;aAC9G,MAAM,CAAC,CAAC,CAAC,EAAE,CAA4B,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,EAAE,EAA4B,CAAC;aACnG,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,KAAoB,CAAC,CAAC,CAAC;IAC1D,CAAC;IAED,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;QAC3B,QAAQ,CAAC,KAAK,CAAC,CAAC;IAClB,CAAC;IAED,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC1B,CAAC","sourcesContent":["import { ReflectiveInjector } from '../reflective_injector';\nimport { ResolvedReflectiveProvider, ResolvedReflectiveFactory, ReflectiveDependency } from '../reflective_provider';\n\ntype Constructor = new (...args: any[]) => any;\n\n/**\n * This utility function receives a spread of injectable classes\n * and returns an array of all their dependencies. Also resolves\n * optional dependencies.\n *\n * ### Important:\n *\n * Dynamically resolving dependencies using this function\n * will not play nice with static analysis tools, including tree-shaking.\n * From a static analysis perspective, any dependencies which are only resolved\n * using this function will look as though they are not used (and will be\n * removed by tree-shaking). This *severely* limits the usefulness of this function.\n *\n * ### Example:\n *\n * ```typescript\n * class HTTP {}\n * class Database {}\n *\n * // commenting out the decorator because the `@` symbol is spoiling\n * // jsDoc rendering in vscode\n * // @Injectable()\n * class PersonService {\n *   constructor(\n *     private http: HTTP,\n *     private database: Database,\n *   ) {}\n * }\n *\n * // @Injectable()\n * class OrganizationService {\n *   constructor(\n *     private http: HTTP,\n *     private personService: PersonService,\n *   ) {}\n * }\n *\n * const injector = ReflectiveInjector.resolveAndCreate(\n *   resolveDependencies(OrganizationService)\n * );\n *\n * const organizationService = injector.get(OrganizationService);\n * ```\n */\nexport function resolveDependencies(...inputs: Constructor[]) {\n  const deps = new Set<Constructor>();\n\n  function resolver(klass: Constructor) {\n    if (deps.has(klass)) return;\n\n    deps.add(klass);\n\n    // resolve all dependencies of the provided class and run the `resolver()` function\n    // on their constructor functions.\n    ReflectiveInjector.resolve([klass])\n      .reduce((a, x: ResolvedReflectiveProvider) => a.concat(x.resolvedFactories), [] as ResolvedReflectiveFactory[])\n      .reduce((a, r: ResolvedReflectiveFactory) => a.concat(r.dependencies), [] as ReflectiveDependency[])\n      .forEach((d) => resolver(d.key.token as Constructor));\n  }\n\n  for (const input of inputs) {\n    resolver(input);\n  }\n\n  return Array.from(deps);\n}\n"]}